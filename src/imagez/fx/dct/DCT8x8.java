/*
 * Copyright (c) 2010, Guoshen Yu <yu@cmap.polytechnique.fr>,
 *                     Guillermo Sapiro <guille@umn.edu>
 * Copyright (C) 2011, Michael Zucchi <notzed@gmail.com>
 * All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package imagez.fx.dct;

/**
 * Implements an 8x8 DCT8x8 forward and inverse transform.
 *
 * I took the original from Guoshen and Guillermo, removed
 * the transpose step and changed the api.
 * 
 * A new DCT8x8 instance must exist for each thread.
 * @author notzed
 */
public class DCT8x8 implements DCT2D {

	float[] tmp = new float[PATCHSIZE * PATCHSIZE];
	static final int PATCHSIZE = 8;
// Define a 8x8 1D DCT8x8 basis (each ROW is a vector of the forward
// transform basis).
	static float DCTbasis[] = {
		0.35355339059327373085750423342688009142875671386719f,
		0.35355339059327373085750423342688009142875671386719f,
		0.35355339059327373085750423342688009142875671386719f,
		0.35355339059327373085750423342688009142875671386719f,
		0.35355339059327373085750423342688009142875671386719f,
		0.35355339059327373085750423342688009142875671386719f,
		0.35355339059327373085750423342688009142875671386719f,
		0.35355339059327373085750423342688009142875671386719f,
		//
		0.49039264020161521528962111915461719036102294921875f,
		0.41573480615127261783570133957255166023969650268555f,
		0.27778511650980114433551193542371038347482681274414f,
		0.09754516100806412404189416065491968765854835510254f,
		-0.09754516100806412404189416065491968765854835510254f,
		-0.27778511650980114433551193542371038347482681274414f,
		-0.41573480615127261783570133957255166023969650268555f,
		-0.49039264020161521528962111915461719036102294921875f,
		//
		0.46193976625564336924156805253005586564540863037109f,
		0.19134171618254489088961634024599334225058555603027f,
		-0.19134171618254489088961634024599334225058555603027f,
		-0.46193976625564336924156805253005586564540863037109f,
		-0.46193976625564336924156805253005586564540863037109f,
		-0.19134171618254489088961634024599334225058555603027f,
		0.19134171618254489088961634024599334225058555603027f,
		0.46193976625564336924156805253005586564540863037109f,
		//
		0.41573480615127261783570133957255166023969650268555f,
		-0.09754516100806417955304539191274670884013175964355f,
		-0.49039264020161521528962111915461719036102294921875f,
		-0.27778511650980108882436070416588336229324340820312f,
		0.27778511650980108882436070416588336229324340820312f,
		0.49039264020161521528962111915461719036102294921875f,
		0.09754516100806417955304539191274670884013175964355f,
		-0.41573480615127261783570133957255166023969650268555f,
		//
		0.35355339059327378636865546468470711261034011840820f,
		-0.35355339059327378636865546468470711261034011840820f,
		-0.35355339059327378636865546468470711261034011840820f,
		0.35355339059327378636865546468470711261034011840820f,
		0.35355339059327378636865546468470711261034011840820f,
		-0.35355339059327378636865546468470711261034011840820f,
		-0.35355339059327378636865546468470711261034011840820f,
		0.35355339059327378636865546468470711261034011840820f,
		//
		0.27778511650980114433551193542371038347482681274414f,
		-0.49039264020161532631192358167027123272418975830078f,
		0.09754516100806412404189416065491968765854835510254f,
		0.41573480615127261783570133957255166023969650268555f,
		-0.41573480615127261783570133957255166023969650268555f,
		-0.09754516100806412404189416065491968765854835510254f,
		0.49039264020161532631192358167027123272418975830078f,
		-0.27778511650980114433551193542371038347482681274414f,
		//
		0.19134171618254491864519195587490685284137725830078f,
		-0.46193976625564336924156805253005586564540863037109f,
		0.46193976625564336924156805253005586564540863037109f,
		-0.19134171618254491864519195587490685284137725830078f,
		-0.19134171618254491864519195587490685284137725830078f,
		0.46193976625564336924156805253005586564540863037109f,
		-0.46193976625564336924156805253005586564540863037109f,
		0.19134171618254491864519195587490685284137725830078f,
		//
		0.09754516100806416567525758409828995354473590850830f,
		-0.27778511650980108882436070416588336229324340820312f,
		0.41573480615127267334685257083037868142127990722656f,
		-0.49039264020161521528962111915461719036102294921875f,
		0.49039264020161521528962111915461719036102294921875f,
		-0.41573480615127267334685257083037868142127990722656f,
		0.27778511650980108882436070416588336229324340820312f,
		-0.09754516100806416567525758409828995354473590850830f
	};

	private void forward1Drow(float[] in, int soff, float[] out, int doff) {
		// forward transform
		for (int j = 0; j < PATCHSIZE; j++) {
			float v = 0;
			for (int i = 0; i < PATCHSIZE; i++) {
				v += in[i + soff] * DCTbasis[j*PATCHSIZE+i];
			}
			out[j + doff] = v;
		}
	}

	private void forward1Dcol(float[] in, int soff, float[] out, int doff) {
		// forward transform
		for (int j = 0; j < PATCHSIZE; j++) {
			float v = 0;
			for (int i = 0; i < PATCHSIZE; i++) {
				v += in[i * PATCHSIZE + soff] * DCTbasis[j*PATCHSIZE+i];
			}
			out[j * PATCHSIZE + doff] = v;
		}
	}

	private void inverse1Drow(float[] in, int soff, float[] out, int doff) {
		// reverse transform
		for (int j = 0; j < PATCHSIZE; j++) {
			float v = 0;
			for (int i = 0; i < PATCHSIZE; i++) {
				v += in[i + soff] * DCTbasis[i*PATCHSIZE+j];
			}
			out[j + doff] = v;
			//System.out.printf(" %d,%d %f\n", j, doff, v);
		}
		//System.out.println();
	}

	private void inverse1Dcol(float[] in, int soff, float[] out, int doff) {
		// reverse transform
		for (int j = 0; j < PATCHSIZE; j++) {
			float v = 0;
			for (int i = 0; i < PATCHSIZE; i++) {
				v += in[i * PATCHSIZE + soff] * DCTbasis[i*PATCHSIZE+j];
			}
			out[j * PATCHSIZE + doff] = v;
			//System.out.printf(" %d,%d %f\n", j*PATCHSIZE, doff, v);
		}
		//System.out.println();
	}

	/**
	 * Forward 8x8 DCT8x8 for an 8x8 source patch.
	 * @param patch
	 * @param offset 
	 */
	public void forward(float[] patch, int offset) {
		// transform row by row
		for (int j = 0; j < PATCHSIZE; j++) {
			forward1Drow(patch, offset + j * PATCHSIZE, tmp, j * PATCHSIZE);
		}
		// transform by column
		for (int j = 0; j < PATCHSIZE; j++) {
			forward1Dcol(tmp, j, patch, offset + j);
		}
	}

	public void inverse(float[] patch, int offset) {
		// transform row by row
		for (int j = 0; j < PATCHSIZE; j++) {
			inverse1Drow(patch, offset + j * PATCHSIZE, tmp, j * PATCHSIZE);
		}
		// transform by column
		for (int j = 0; j < PATCHSIZE; j++) {
			inverse1Dcol(tmp, j, patch, offset + j);
		}
	}
}
